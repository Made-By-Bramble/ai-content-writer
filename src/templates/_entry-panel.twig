{% if settings.openAiApiKey %}
<h6 class="first">{{ 'AI Content Writer'|t('ai-content-writer') }}</h6>
<div class="meta">
    
    {# Extract entry type information for new entry support #}
    {% set entryTypeId = entry.type.id ?? (craft.app.request.getParam('typeId') ?? null) %}
    {% set sectionId = entry.section.id ?? (craft.app.request.getParam('sectionId') ?? null) %}
    
    
    {# AI Content Writer Section #}
    <div class="ai-content-writer-panel" 
         data-entry-id="{{ entry.id ?? '' }}"
         data-entry-type-id="{{ entryTypeId }}"
         data-section-id="{{ sectionId }}"
         data-is-new-entry="{{ entry.id is empty ? 'true' : 'false' }}">
        
        {# Target Field selector #}
        <div class="field" data-attribute="ai-target-field">
            <div class="heading">
                <label class="h6" for="ai-target-field">{{ 'Target Field'|t('ai-content-writer') }}</label>
            </div>
            <div class="input">
                <div class="select fullwidth">
                    <select id="ai-target-field" name="targetField" class="fullwidth">
                        <option value="">{{ 'Select a field...'|t('ai-content-writer') }}</option>
                    </select>
                </div>
            </div>
        </div>
        
        {# Content Prompt #}
        <div class="field" data-attribute="ai-prompt">
            <div class="heading">
                <label class="h6" for="ai-prompt">{{ 'Content Prompt'|t('ai-content-writer') }}</label>
            </div>
            <div class="input ltr">
                <textarea id="ai-prompt" name="prompt" rows="3" class="nicetext text fullwidth" 
                    placeholder="{{ 'Describe the content you want to generate...'|t('ai-content-writer') }}" 
                    aria-label="Content Prompt" style="min-height: 72px;"></textarea>
            </div>
        </div>
        
        {# Generate Button #}
        <div class="field">
            <div class="input">
                <button type="button" id="ai-generate-content" class="btn submit fullwidth">
                    {{ 'Generate Content'|t('ai-content-writer') }}
                </button>
            </div>
        </div>
        
        {# Insert Button (hidden initially) #}
        <div class="field" id="ai-insert-button-container" style="display:none;">
            <div class="input">
                <button type="button" id="ai-insert-content" class="btn secondary fullwidth">
                    {{ 'Insert into Field'|t('ai-content-writer') }}
                </button>
            </div>
        </div>
        
        {# Preview area (hidden initially) #}
        <div id="ai-content-preview" class="field content-preview" style="display:none;">
            <div class="heading">
                <label class="h6">{{ 'Generated Content'|t('ai-content-writer') }}</label>
            </div>
            <div class="input">
                <div class="preview-content" style="background-color: #fafafa; border: 1px solid #e3e5e8; border-radius: 3px; padding: 14px; max-height: 200px; overflow-y: auto; white-space: pre-wrap; font-size: 13px; line-height: 1.4;"></div>
            </div>
        </div>
    </div>
    
</div>

{% js %}
// AI Content Writer - Context-aware initialization for main editor and slideout contexts
(function() {
    'use strict';
    
    // Detect editing context (main editor vs slideout)
    function getPluginContext(searchRoot = document) {
        let slideoutContainer = null;
        
        if (searchRoot !== document) {
            if (searchRoot.classList && searchRoot.classList.contains('slideout-container')) {
                slideoutContainer = searchRoot;
            } else {
                slideoutContainer = searchRoot.querySelector('.slideout-container');
            }
        }
        
        if (!slideoutContainer) {
            slideoutContainer = document.querySelector('.slideout-container');
        }
        
        const isSlideout = !!slideoutContainer;
        
        return {
            type: isSlideout ? 'slideout' : 'main',
            container: isSlideout ? slideoutContainer : document,
            isSlideout: isSlideout,
            isMainEditor: !isSlideout
        };
    }
    
    // Initialize plugin panel in given context
    function initializeAiContentWriter(searchRoot = document) {
        let panel = null;
        if (searchRoot === document) {
            panel = document.querySelector('.ai-content-writer-panel');
        } else {
            panel = searchRoot.querySelector('.ai-content-writer-panel');
            if (!panel && searchRoot.classList && searchRoot.classList.contains('ai-content-writer-panel')) {
                panel = searchRoot;
            }
            if (!panel) {
                const slideouts = searchRoot.querySelectorAll('.slideout-container');
                for (let slideout of slideouts) {
                    panel = slideout.querySelector('.ai-content-writer-panel');
                    if (panel) break;
                }
            }
        }
        
        if (!panel || panel.dataset.aiInitialized) {
            return false;
        }
        
        panel.dataset.aiInitialized = 'true';
        const context = getPluginContext(searchRoot);
        return setupPanelWithContext(panel, context);
    }
    
    function setupPanelWithContext(panel, context) {
        const entryData = getEntryContextData(panel);
        
        if (!entryData.entryTypeId && !entryData.entryId) {
            console.error('AI Content Writer: No entry type or entry ID available in', context.type, 'context');
            return false;
        }
        
        return initializePanelFunctionality(panel, entryData, context);
    }
    
    function getEntryContextData(panel) {
        return {
            entryId: panel.dataset.entryId || null,
            entryTypeId: panel.dataset.entryTypeId || null,
            isNewEntry: panel.dataset.isNewEntry === 'true'
        };
    }
    
    function initializePanelFunctionality(panel, entryData, context) {
        const searchRoot = context.isSlideout ? context.container : document;
        
        // Find UI elements (handles namespaced IDs in slideouts)
        const fieldSelect = searchRoot.querySelector('#ai-target-field') || 
                           searchRoot.querySelector('[id$="-ai-target-field"]') ||
                           searchRoot.querySelector('select[name*="ai-target-field"]');
        const promptTextarea = searchRoot.querySelector('#ai-prompt') || 
                              searchRoot.querySelector('[id$="-ai-prompt"]') ||
                              searchRoot.querySelector('textarea[name*="ai-prompt"]');
        const generateBtn = searchRoot.querySelector('#ai-generate-content') || 
                           searchRoot.querySelector('[id$="-ai-generate-content"]') ||
                           searchRoot.querySelector('button[id*="ai-generate-content"]');
        const insertBtn = searchRoot.querySelector('#ai-insert-content') || 
                         searchRoot.querySelector('[id$="-ai-insert-content"]') ||
                         searchRoot.querySelector('button[id*="ai-insert-content"]');
        const insertBtnContainer = searchRoot.querySelector('#ai-insert-button-container') || 
                                  searchRoot.querySelector('[id$="-ai-insert-button-container"]') ||
                                  searchRoot.querySelector('div[id*="ai-insert-button-container"]');
        const preview = searchRoot.querySelector('#ai-content-preview') || 
                       searchRoot.querySelector('[id$="-ai-content-preview"]') ||
                       searchRoot.querySelector('div[id*="ai-content-preview"]');
        
        if (!fieldSelect || !promptTextarea || !generateBtn || !insertBtn || !insertBtnContainer || !preview) {
            console.error('AI Content Writer: Could not find required UI elements in', context.type, 'context');
            console.error('AI Content Writer: Missing elements details:', {
                fieldSelect: !!fieldSelect,
                promptTextarea: !!promptTextarea,
                generateBtn: !!generateBtn,
                insertBtn: !!insertBtn,
                insertBtnContainer: !!insertBtnContainer,
                preview: !!preview
            });
            return false;
        }
        
        const previewContent = preview.querySelector('.preview-content');
        
        let generatedContent = '';
        let selectedFieldInfo = null;
        
        loadAvailableFields(panel, entryData, context);
        
        // Event handlers
        fieldSelect.addEventListener('change', function() {
            const selectedOption = fieldSelect.options[fieldSelect.selectedIndex];
            if (selectedOption.value) {
                selectedFieldInfo = {
                    handle: selectedOption.value,
                    name: selectedOption.textContent,
                    type: selectedOption.dataset.fieldType,
                    format: selectedOption.dataset.format
                };
            } else {
                selectedFieldInfo = null;
            }
            
            // Clear preview when field changes
            clearPreview();
        });
        
        // Generate button handler
        generateBtn.addEventListener('click', async function() {
            const fieldHandle = fieldSelect.value;
            const prompt = promptTextarea.value.trim();
            
            if (!fieldHandle || !prompt) {
                Craft.cp.displayError('{{ "Please select a field and enter a prompt"|t("ai-content-writer") }}');
                return;
            }
            
            if (!selectedFieldInfo) {
                Craft.cp.displayError('{{ "Field information not available"|t("ai-content-writer") }}');
                return;
            }
            
            // Update button state
            generateBtn.disabled = true;
            generateBtn.textContent = '{{ "Generating..."|t("ai-content-writer") }}';
            clearPreview();
            
            try {
                const actionUrl = Craft.getActionUrl("ai-content-writer/content/generate");
                const response = await fetch(actionUrl, {
                    method: 'POST',
                    headers: {
                        'X-CSRF-Token': Craft.csrfTokenValue,
                        'Accept': 'application/json',
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        entryId: entryData.entryId,
                        fieldHandle: fieldHandle,
                        prompt: prompt,
                        typeId: entryData.entryTypeId
                        // Note: sectionId is omitted - backend will determine it from entryId
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                
                if (data.success) {
                    generatedContent = data.content;
                    showPreview(data.content);
                    Craft.cp.displayNotice('{{ "Content generated successfully"|t("ai-content-writer") }}');
                } else {
                    Craft.cp.displayError('{{ "Generation failed"|t("ai-content-writer") }}: ' + data.error);
                }
            } catch (error) {
                console.error('AI Content Writer: Generation error:', error);
                Craft.cp.displayError('{{ "Generation failed"|t("ai-content-writer") }}: ' + error.message);
            } finally {
                // Reset button state
                generateBtn.disabled = false;
                generateBtn.textContent = '{{ "Generate Content"|t("ai-content-writer") }}';
            }
        });
        
        // Insert button handler
        insertBtn.addEventListener('click', function() {
            if (!selectedFieldInfo || !generatedContent) {
                Craft.cp.displayError('{{ "No content to insert"|t("ai-content-writer") }}');
                return;
            }
            
            // Attempt to insert content into the field
            const inserted = insertContentIntoField(selectedFieldInfo, generatedContent, context);
            
            if (inserted) {
                Craft.cp.displayNotice('{{ "Content inserted into field"|t("ai-content-writer") }}');
                
                // Reset UI
                clearPreview();
                promptTextarea.value = '';
            } else {
                Craft.cp.displayError('{{ "Could not insert content into field"|t("ai-content-writer") }}');
            }
        });
        
        function showPreview(content) {
            // Format content for preview based on field type
            let formattedContent = content;
            
            if (selectedFieldInfo && selectedFieldInfo.format === 'html') {
                previewContent.innerHTML = formattedContent;
            } else {
                previewContent.textContent = formattedContent;
            }
            
            preview.style.display = 'block';
            insertBtnContainer.style.display = 'block';
        }
        
        function clearPreview() {
            preview.style.display = 'none';
            insertBtnContainer.style.display = 'none';
            previewContent.innerHTML = '';
            generatedContent = '';
        }
        
        return true;
    }
    
    // Load available fields from backend
    function loadAvailableFields(panel, entryData, context) {
        const cleanedData = Object.fromEntries(
            Object.entries(entryData).filter(([_, v]) => v !== null)
        );
        
        const actionUrl = Craft.getActionUrl("ai-content-writer/content/get-available-fields");
        
        fetch(actionUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRF-Token': Craft.csrfTokenValue,
                'Accept': 'application/json'
            },
            body: JSON.stringify(cleanedData)
        })
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            if (data.success) {
                populateFieldSelector(data.fields, context);
                
            } else {
                console.error('AI Content Writer: Failed to load available fields:', data.error);
            }
        })
        .catch(error => {
            console.error('AI Content Writer: Error loading available fields:', error);
        });
    }
    
    function populateFieldSelector(fields, context) {
        const searchRoot = context.isSlideout ? context.container : document;
        const fieldSelect = searchRoot.querySelector('#ai-target-field') || 
                           searchRoot.querySelector('[id$="-ai-target-field"]') ||
                           searchRoot.querySelector('select[name*="ai-target-field"]');
        
        if (!fieldSelect) {
            console.error('AI Content Writer: Could not find field selector in', context.type, 'context');
            console.error('AI Content Writer: Tried selectors:', [
                '#ai-target-field',
                '[id$="-ai-target-field"]', 
                'select[name*="ai-target-field"]'
            ]);
            return;
        }
        
        // Clear existing options except the first
        fieldSelect.innerHTML = '<option value="">' + {{ 'Select a field...'|t('ai-content-writer')|json_encode|raw }} + '</option>';
        
        fields.forEach(field => {
            const option = document.createElement('option');
            option.value = field.handle;
            option.textContent = field.name;
            option.dataset.fieldType = field.type;
            option.dataset.format = field.format;
            fieldSelect.appendChild(option);
        });
    }
    
    // Context-aware field insertion
    function insertContentIntoField(fieldInfo, content, context) {
        const fieldHandle = fieldInfo.handle;
        const fieldType = fieldInfo.type;
        
        // Find field container with context awareness
        const fieldContainer = findFieldContainerInContext(fieldHandle, context);
        if (!fieldContainer) {
            if (window.Craft && Craft.devMode) {
                console.error('AI Content Writer: Could not find field container for:', fieldHandle, 'in', context.type, 'context');
            }
            return false;
        }
        
        // Handle different field types
        switch (fieldType) {
            case 'craft\\fields\\PlainText':
                return insertIntoPlainTextField(fieldContainer, content);
                
            case 'craft\\redactor\\Field':
                return insertIntoRedactorField(fieldContainer, content);
                
            case 'craft\\ckeditor\\Field':
                return insertIntoCKEditorField(fieldContainer, content);
                
            case 'craft\\fields\\Table':
                return insertIntoTableField(fieldContainer, content);
                
            default:
                return insertIntoPlainTextField(fieldContainer, content);
        }
    }
    
    function findFieldContainerInContext(fieldHandle, context) {
        const searchRoot = context.isSlideout ? context.container : document;
        
        const selectors = [
            `[data-attribute="${fieldHandle}"]`,
            `.field[data-attribute="${fieldHandle}"]`,
            `#fields-${fieldHandle}`,
            `[data-field="${fieldHandle}"]`
        ];
        
        for (const selector of selectors) {
            const container = searchRoot.querySelector(selector);
            if (container) {
                return container;
            }
        }
        
        return null;
    }
    
    // Field insertion functions (unchanged from original)
    function insertIntoPlainTextField(fieldContainer, content) {
        const textarea = fieldContainer.querySelector('textarea');
        const input = fieldContainer.querySelector('input[type="text"]');
        
        if (textarea) {
            textarea.value = content;
            textarea.dispatchEvent(new Event('input', { bubbles: true }));
            return true;
        } else if (input) {
            input.value = content;
            input.dispatchEvent(new Event('input', { bubbles: true }));
            return true;
        }
        
        return false;
    }
    
    function insertIntoRedactorField(fieldContainer, content) {
        const redactorFrame = fieldContainer.querySelector('.redactor-in');
        
        if (redactorFrame && typeof $ !== 'undefined') {
            const redactorInstance = $(redactorFrame).data('redactor');
            if (redactorInstance) {
                redactorInstance.source.setCode(content);
                return true;
            }
        }
        
        // Fallback to textarea if Redactor isn't initialized
        const textarea = fieldContainer.querySelector('textarea');
        if (textarea) {
            textarea.value = content;
            textarea.dispatchEvent(new Event('input', { bubbles: true }));
            return true;
        }
        
        return false;
    }
    
    function insertIntoCKEditorField(fieldContainer, content) {
        const ckeditor = fieldContainer.querySelector('.ck-editor__editable');
        
        if (ckeditor && ckeditor.ckeditorInstance) {
            ckeditor.ckeditorInstance.setData(content);
            return true;
        }
        
        // Fallback to textarea if CKEditor isn't initialized
        const textarea = fieldContainer.querySelector('textarea');
        if (textarea) {
            textarea.value = content;
            textarea.dispatchEvent(new Event('input', { bubbles: true }));
            return true;
        }
        
        return false;
    }
    
    function insertIntoTableField(fieldContainer, content) {
        Craft.cp.displayNotice('{{ "Table content generated. Please manually structure the content into table rows and columns."|t("ai-content-writer") }}');
        return true;
    }
    
    // Initialize on page load
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', function() {
            initializeAiContentWriter();
        });
    } else {
        initializeAiContentWriter();
    }
    
    // Initialize for slideout containers
    if (typeof Craft !== 'undefined') {
        if (typeof $ !== 'undefined') {
            $(document).on('slideout:ready slideout:loaded slideout:show slideout:open', function(event) {
                setTimeout(function() {
                    initializeAiContentWriter(event.target);
                }, 100);
            });
            
            $(document).on('slide:ready slide:loaded slide:show slide:open', function(event) {
                setTimeout(function() {
                    initializeAiContentWriter(event.target);
                }, 100);
            });
        }
        
        // DOM mutation observer for dynamic content
        const observer = new MutationObserver(function(mutations) {
            mutations.forEach(function(mutation) {
                if (mutation.type === 'childList') {
                    mutation.addedNodes.forEach(function(node) {
                        if (node.nodeType === 1) {
                            if (node.classList && (
                                node.classList.contains('slideout-container') ||
                                node.classList.contains('slide-container') ||
                                node.classList.contains('hud') ||
                                node.classList.contains('modal')
                            )) {
                                setTimeout(function() {
                                    initializeAiContentWriter(node);
                                }, 150);
                            }
                            
                            if (node.querySelectorAll) {
                                const slideouts = node.querySelectorAll('.slideout-container, .slide-container, .hud, .modal');
                                if (slideouts.length > 0) {
                                    slideouts.forEach(function(slideout) {
                                        setTimeout(function() {
                                            initializeAiContentWriter(slideout);
                                        }, 150);
                                    });
                                }
                            }
                            
                            if (node.querySelectorAll) {
                                const panels = node.querySelectorAll('.ai-content-writer-panel');
                                if (panels.length > 0) {
                                    setTimeout(function() {
                                        initializeAiContentWriter(node);
                                    }, 200);
                                }
                            }
                        }
                    });
                }
            });
        });
        
        observer.observe(document.body, {
            childList: true,
            subtree: true,
            attributes: true,
            attributeFilter: ['class', 'style']
        });
        
        // Fallback: periodic check for uninitialized panels
        setInterval(function() {
            const uninitializedPanels = document.querySelectorAll('.ai-content-writer-panel:not([data-ai-initialized])');
            if (uninitializedPanels.length > 0) {
                uninitializedPanels.forEach(function(panel) {
                    const container = panel.closest('.slideout-container, .slide-container, .hud, .modal') || document;
                    initializeAiContentWriter(container);
                });
            }
        }, 1000);
    }
    
})();
{% endjs %}

{% css %}
.ai-content-writer-panel {
    padding: 14px;
    border-top: 1px solid #e3e5e8;
    margin-top: 14px;
}

.ai-content-writer-panel h3 {
    margin-bottom: 14px;
    font-size: 14px;
    font-weight: bold;
    color: #29323d;
}

.ai-content-writer-panel .field {
    margin-bottom: 14px;
}

.ai-content-writer-panel .field label {
    display: block;
    margin-bottom: 5px;
    font-weight: bold;
    color: #29323d;
    font-size: 13px;
}

.ai-content-writer-panel .buttons {
    display: flex;
    gap: 7px;
    margin-bottom: 14px;
}

.ai-content-writer-panel .buttons .btn {
    flex: 1;
}

.ai-content-writer-panel .content-preview {
    background: #f7f7f8;
    border: 1px solid #e3e5e8;
    border-radius: 4px;
    padding: 14px;
    margin-top: 14px;
}

.ai-content-writer-panel .content-preview h4 {
    margin-bottom: 7px;
    font-size: 12px;
    text-transform: uppercase;
    color: #606d7b;
    font-weight: bold;
}

.ai-content-writer-panel .preview-content {
    background: white;
    padding: 10px;
    border-radius: 3px;
    max-height: 300px;
    overflow-y: auto;
    border: 1px solid #e3e5e8;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
    font-size: 13px;
    line-height: 1.4;
    color: #29323d;
}

.ai-content-writer-panel #ai-prompt {
    resize: vertical;
    min-height: 80px;
}

.ai-content-writer-panel select.fullwidth,
.ai-content-writer-panel textarea.fullwidth {
    width: 100%;
}

.ai-content-writer-panel .btn {
    font-size: 13px;
    padding: 8px 12px;
    border-radius: 3px;
    border: none;
    cursor: pointer;
    text-decoration: none;
    display: inline-block;
    text-align: center;
}

.ai-content-writer-panel .btn.submit {
    background: #0d78f2;
    color: white;
}

.ai-content-writer-panel .btn.submit:hover {
    background: #0b6bd9;
}

.ai-content-writer-panel .btn.submit:disabled {
    background: #9aa5b1;
    cursor: not-allowed;
}

.ai-content-writer-panel .btn.secondary {
    background: #606d7b;
    color: white;
}

.ai-content-writer-panel .btn.secondary:hover {
    background: #515c68;
}

/* Loading state styles */
.ai-content-writer-panel .btn:disabled {
    opacity: 0.7;
    cursor: not-allowed;
}

/* Field selector styles */
.ai-content-writer-panel select {
    height: 36px;
    padding: 8px 12px;
    border: 1px solid #e3e5e8;
    border-radius: 3px;
    background: white;
    font-size: 13px;
    color: #29323d;
}

.ai-content-writer-panel select:focus {
    border-color: #0d78f2;
    outline: none;
    box-shadow: 0 0 0 2px rgba(13, 120, 242, 0.1);
}

/* Textarea styles */
.ai-content-writer-panel textarea {
    padding: 8px 12px;
    border: 1px solid #e3e5e8;
    border-radius: 3px;
    background: white;
    font-size: 13px;
    color: #29323d;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
}

.ai-content-writer-panel textarea:focus {
    border-color: #0d78f2;
    outline: none;
    box-shadow: 0 0 0 2px rgba(13, 120, 242, 0.1);
}

.ai-content-writer-panel textarea::placeholder {
    color: #8f98a3;
}
{% endcss %}
{% endif %}